#Cada unos de los codigos son un archivo distinto para el codigo que esta documentado con comentarios y almacenado en un solo archivo llamado weather_news_dashboard

# Clima.py

import requests
from config import OPENWEATHER_API_KEY  # Importa la clave API desde config.py

def obtener_clima():
    # URL de la API con par√°metros: ciudad (La Serena), pa√≠s (CL), unidades m√©tricas y lenguaje espa√±ol
    url = "http://api.openweathermap.org/data/2.5/weather?q=La%20Serena,CL&appid={}&units=metric&lang=es".format(OPENWEATHER_API_KEY)
    
    # Hace la petici√≥n GET a la API
    response = requests.get(url)
    
    # Extrae y devuelve solo los datos relevantes en un diccionario
    return {
        "ciudad": "La Serena",  # Nombre fijo (podr√≠a dinamizarse)
        "temperatura": response.json()["main"]["temp"],  # Temp en ¬∞C
        "humedad": response.json()["main"]["humidity"],  # Humedad en %
        "condicion": response.json()["weather"][0]["description"]  # Ej: "cielo claro"
    }

# config.py

import os
from dotenv import load_dotenv  # Para cargar variables de entorno desde .env

# Carga variables de entorno (si existe .env)
load_dotenv()

# Configuraci√≥n de APIs (usa valores de .env o valores por defecto)
OPENWEATHER_API_KEY = os.getenv('OPENWEATHER_API_KEY', '30ffbbcab161d62c59ee99d603f37d80')
NEWS_API_KEY = os.getenv('NEWS_API_KEY', 'b516d2284f1243c8a894c3c0d7c583e4') #aqui estan agregadas mis llaves pero esas llaves pueden ser cambiadas 
GMAIL_RECIPIENT = "reynaneon09@gmail.com"  # Destinatario fijo

# dashboard.py

# Importaciones necesarias
from datetime import datetime  # Para manejar fechas/horas
from Clima import obtener_clima  # Funci√≥n que obtiene datos del clima
from Noticias import obtener_noticias  # Funci√≥n que obtiene noticias
from Paises import obtener_info_chile  # Funci√≥n que obtiene datos de Chile
from Gmail import enviar_reporte  # Funci√≥n que env√≠a el correo
import logging  # Para registrar eventos/errores

# Configuraci√≥n b√°sica de logging (registro de actividad)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def generar_reporte():
    """
    Funci√≥n principal que:
    1. Obtiene datos de clima, noticias y pa√≠s
    2. Formatea el reporte
    3. Lo env√≠a por correo
    """
    try:
        logger.info("üîÑ Generando reporte...")
        
        # --- 1. OBTENER DATOS ---
        clima = obtener_clima()  # Llama a la API del clima
        noticias = obtener_noticias()  # Llama a la API de noticias
        pais = obtener_info_chile()  # Llama a la API de pa√≠ses

        # --- 2. FORMATEAR REPORTE ---
        # Encabezado con fecha/hora actual
        cuerpo_reporte = f"""
        üåé Reporte Diario - Chile üá®üá±
        üìÖ Fecha: {datetime.now().strftime('%d/%m/%Y %H:%M')}
        """

        # Secci√≥n del clima
        cuerpo_reporte += f"""
        üå§Ô∏è Clima en {clima['ciudad']}:
        - Temperatura: {clima['temperatura']}¬∞C
        - Humedad: {clima['humedad']}%
        - Condici√≥n: {clima['condicion'].capitalize()}
        """

        # Secci√≥n de noticias (solo las 3 primeras)
        cuerpo_reporte += "\nüì∞ √öltimas noticias:\n"
        for i, noticia in enumerate(noticias[:3], 1):
            cuerpo_reporte += f"  {i}. {noticia['titulo']} ({noticia['fuente']})\n"

        # Secci√≥n del pa√≠s
        cuerpo_reporte += f"""
        ‚ÑπÔ∏è Informaci√≥n del pa√≠s:
        - Capital: {pais['capital']}
        - Poblaci√≥n: {pais['poblacion']:,}
        - Moneda: {pais['moneda']}
        """

        # --- 3. ENV√çO DEL CORREO ---
        asunto = f"Reporte Chile {datetime.now().strftime('%d/%m')}"
        enviar_reporte(asunto, cuerpo_reporte.strip())  # strip() elimina espacios extras
        
        logger.info("‚úÖ Reporte generado y enviado")
        return cuerpo_reporte

    except Exception as e:
        logger.error(f"‚ùå Error al generar reporte: {str(e)}")
        return None

# Noticias.py

import requests
from config import NEWS_API_KEY  # Importa la clave API desde config.py

def obtener_noticias():
    # URL para obtener titulares de Chile (country=cl)
    url = f"https://newsapi.org/v2/top-headlines?country=cl&apiKey={NEWS_API_KEY}"
    
    # Petici√≥n GET y conversi√≥n a JSON
    response = requests.get(url)
    
    # Procesa los art√≠culos: lista de diccionarios con t√≠tulo y fuente
    return [
        {
            "titulo": art["title"],  # Titular de la noticia
            "fuente": art["source"]["name"]  # Nombre del medio (ej: "CNN Chile")
        } 
        for art in response.json()["articles"][:3]  # Solo los 3 primeros
    ]

# Gmail.py

import os
import base64
from email.mime.text import MIMEText
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google_auth_oauthlib.flow import InstalledAppFlow
import logging

# Configuraci√≥n b√°sica de logs (registra errores y eventos)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Permisos necesarios (solo para enviar correos)
SCOPES = ['https://www.googleapis.com/auth/gmail.send']

def autenticar_gmail():
    """Autentica con Gmail API usando OAuth 2.0"""
    creds = None
    
    # 1. Intenta cargar credenciales existentes (token.json)
    if os.path.exists('token.json'):
        try:
            creds = Credentials.from_authorized_user_file('token.json', SCOPES)
            logger.info("‚úÖ Token cargado exitosamente")
        except Exception as e:
            logger.error(f"‚ùå Token corrupto. Generando uno nuevo: {e}")
            os.remove('token.json')  # Elimina el token inv√°lido
    
    # 2. Si no hay credenciales v√°lidas, inicia flujo de autenticaci√≥n
    if not creds or not creds.valid:
        flow = InstalledAppFlow.from_client_secrets_file(
            'credentials.json',  # Archivo descargado de Google Cloud
            SCOPES
        )
        # Abre el navegador para autenticaci√≥n
        creds = flow.run_local_server(port=0)
        
        # Guarda las credenciales para futuras ejecuciones
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
        logger.info("‚úÖ Nuevo token generado")
    
    # Retorna el servicio de Gmail autenticado
    return build('gmail', 'v1', credentials=creds)

def enviar_reporte(asunto, cuerpo, destinatario="reynaneon09@gmail.com"):
    """Env√≠a un correo electr√≥nico con el reporte"""
    try:
        # 1. Autenticaci√≥n
        service = autenticar_gmail()
        
        # 2. Crea el mensaje en formato MIME
        mensaje = MIMEText(cuerpo)  # Cuerpo del correo como texto plano
        mensaje['to'] = destinatario
        mensaje['subject'] = asunto
        
        # 3. Codifica el mensaje en base64 (requerido por Gmail API)
        raw = base64.urlsafe_b64encode(mensaje.as_bytes()).decode()
        
        # 4. Env√≠a el correo
        message = service.users().messages().send(
            userId="me",  # "me" refiere al usuario autenticado
            body={'raw': raw}
        ).execute()
        
        logger.info(f"üìß Correo enviado! ID: {message['id']}")
        return True
    except HttpError as error:
        logger.error(f"‚ùå Error de Gmail API: {error}")
    except Exception as e:
        logger.error(f"‚ùå Error inesperado: {e}")
    return False

# Paises.py

# Importa la librer√≠a 'requests' para hacer peticiones HTTP
import requests

def obtener_info_chile():
    """
    Obtiene informaci√≥n b√°sica de Chile desde la API REST Countries.
    Returns:
        dict: Diccionario con datos clave del pa√≠s.
    """
    
    # 1. Hace la petici√≥n GET a la API
    response = requests.get("https://restcountries.com/v3.1/name/chile")
    
    # Extrae el primer resultado (la API devuelve una lista)
    data = response.json()[0]
    
    # 2. Procesa y devuelve solo los datos relevantes
    return {
        "nombre": data["name"]["common"],  # Nombre com√∫n del pa√≠s ("Chile")
        "capital": data["capital"][0],     # Primera capital del array (Santiago)
        "poblacion": data["population"],   # Poblaci√≥n total
        "moneda": list(data["currencies"].keys())[0]  # C√≥digo de la moneda (CLP)
    }

# Main.py

#!/usr/bin/env python3
"""
Programa principal mejorado para:
- Ejecuci√≥n diaria a las 8:00 AM
- Manejo robusto de errores
- Registro de actividad
- Auto-recuperaci√≥n
"""

import schedule
import time
import logging
from datetime import datetime
from dashboard import generar_reporte

# Configuraci√≥n avanzada de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ReportScheduler:
    def __init__(self):
        self.max_retries = 3
        self.retry_count = 0

    def safe_report_generation(self):
        """Genera el reporte con manejo de errores y reintentos"""
        try:
            logger.info("‚è≥ Iniciando generaci√≥n de reporte...")
            if generar_reporte():
                logger.info("‚úÖ Reporte generado y enviado correctamente")
                self.retry_count = 0  # Resetear contador de reintentos
            else:
                raise Exception("La funci√≥n generar_reporte() devolvi√≥ False")
                
        except Exception as e:
            self.retry_count += 1
            logger.error(f"‚ö†Ô∏è Intento {self.retry_count}/{self.max_retries} fallido: {str(e)}")
            
            if self.retry_count >= self.max_retries:
                logger.critical("üõë M√°ximo de reintentos alcanzado")
                self.send_failure_alert()
                self.retry_count = 0  # Resetear despu√©s de alerta
                
            time.sleep(60 * self.retry_count)  # Backoff exponencial

    def send_failure_alert(self):
        """Env√≠a alerta cuando fallan m√∫ltiples intentos"""
        alert_msg = f"""
        üö® FALLO CR√çTICO EN WEATHER REPORTER
        ---------------------------------
        Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        Fallos consecutivos: {self.max_retries}
        """
        try:
            from Gmail import enviar_reporte
            enviar_reporte("ALERTA: Fallo en Reporte Diario", alert_msg)
        except Exception as e:
            logger.error(f"üìß Fallo al enviar alerta: {str(e)}")

    def run(self):
        """Inicia el programador principal"""
        try:
            # Programaci√≥n regular
            schedule.every().day.at("08:00").do(self.safe_report_generation)
            
            # Ejecuci√≥n inmediata (opcional)
            logger.info("üöÄ Iniciando servicio de reportes meteorol√≥gicos")
            self.safe_report_generation()
            
            # Bucle principal
            while True:
                schedule.run_pending()
                time.sleep(1)  # Reduce consumo de CPU vs sleep(60)
                
        except KeyboardInterrupt:
            logger.info("üëã Detenido por el usuario")
        except Exception as e:
            logger.critical(f"üí• Error cr√≠tico: {str(e)}")
            raise

if __name__ == "__main__":
    scheduler = ReportScheduler()
    scheduler.run()

# credentials.py

Tambien es necesario para el codigo ya que sin esa credencial que proporciona GmailAPI no se podria utilizar el codigo y daria error al no encontrar el archivo.

#token.json

El archivo token tambien es necesario ya que es esencial para la autenticaci√≥n con la API de Gmail sin necesidad de ingresar credenciales manualmente cada vez que se ejecuta el programa, Esta se genera automaticamente al correr por primera vez el comando.

#requerements.txt

requerements    
python dotenv

#ejecutar_reporte.bat

@echo off
cd /d "C:\Users\alexi\OneDrive\Escritorio\weather_news_dashboard"
python Main.py
pause
